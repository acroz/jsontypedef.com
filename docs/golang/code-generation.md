---
title: "Generating Go from JSON Typedef Schemas"
sidebar_label: "Code Generation"
---

JSON Type Definition is a schema language for JSON that's designed for code
generation. In this article, you'll learn:

* How to generate Golang code from a JSON Typedef schema,
* How to use that generated code in your applications

## Prerequisite: Install `jtd-codegen`

The `jtd-codegen` tool generates code from JSON Typedef schemas. It supports
many languages, Golang being one of them. To install `jtd-codegen`, you have a
few options:

### Install with Homebrew

This option is recommended if you're on macOS.

```bash
brew install jsontypedef/jsontypedef/jtd-codegen
```

### Install with Docker

This option is recommended on non-Mac platforms, or if you're running
`jtd-codegen` in some sort of script and you want to make sure that everyone
running the script uses the same version of `jtd-codegen`.

```bash
docker pull jsontypedef/jtd-tools
```

### Install with Cargo

This option is recommended if you already have `cargo` installed, or if you
would prefer to use a version of `jtd-codegen` compiled on your machine:

```bash
cargo install jtd-codegen
```

## Step 1: Write your schema

Before we can generate code from a JSON Typedef schema, we need a schema to work
with. There are a number of ways you can get ahold of a schema:

* You could write one yourself
* You could generate one from existing data, using a tool like
  [`jtd-infer`](/docs/tools/jtd-infer).

Let's assume, for the purposes of this article, that you want to make sure an
inputted JSON is a valid "user", where a user looks likething like this:

```json
{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, 3.14, 42]
}
```

A JSON Typedef schema that can describe this sort of data looks like this:

```json
{
  "properties": {
    "id": { "type": "string" },
    "firstName": { "type": "string" },
    "lastName": { "type": "string" },
    "favoriteNumbers": {
      "elements": { "type": "float64" }
    }
  }
}
```

To follow along with this example, put that schema in a file called
`user.jtd.json` -- there's nothing special about the `.jtd.json` extension, but
it is the conventional file extension to use for JSON Typedef schemas.

## Step 2: Create a directory for your generated code

The `jtd-codegen` tool will always output code into a directory. Create a
directory for `jtd-codegen` to output into.

For this demo, let's make a directory called `user`:

```bash
mkdir user
```

We'll also need to initialize a Go module. Let's do that by running:

```bash
go mod init example.com/codegen-demo
```

## Step 3: Call `jtd-codegen` with your schema

Next, all we need to do is invoke `jtd-codegen`, providing it with the schema
(in `user.jtd.json`) and the output directory (`user/`). Here's how you do that:

```bash
jtd-codegen --go-out=user -- user.jtd.json
```

Or, if you installed `jtd-codegen` with Docker, run:

```bash
docker exec -it jsontypedef/jtd-tools /jtd-codegen --go-out=user -- user.jtd.json
```

Unfortunately, `jtd-codegen` doesn't always output the prettiest code. Run `go
fmt user/index.go` to make it a bit cleaner.

And that's all you have to do! Inside `user/index.go`, you should see a Golang
file that looks something like:

```go
package user

type User struct {
	FavoriteNumbers []float64 `json:"favoriteNumbers"`

	FirstName string `json:"firstName"`

	Id string `json:"id"`

	LastName string `json:"lastName"`
}
```

Try to play around with `user.jtd.json`, and then re-running `jtd-codegen`. Try
adding nested objects, and seeing how `jtd-codegen` behaves!

## Step 4: Integrating the generated code into your app

In the previous steps, we generated code from a JTD schema. But that's not very
useful on its own; what you *really* want to do is be able to use the generated
code in your application. In this section, we'll see how to do that.

`jtd-codegen`-generated code integrates in your app in a three-step process:

1. You accept some JSON input in whatever way makes sense for your application
   -- perhaps you read it from a file, from an HTTP request, or from STDIN.
   That's outside JSON Typedef's purview.

   To keep things super simple, we'll mostly simplify this step in this article.
   We'll just `json.Unmarshal` a hard-coded "input".

2. You validate the JSON input against a JSON Typedef schema. You can do this
   via the `github.com/jsontypedef/json-typedef-go` module.

   If you're unfamiliar with `json-typedef-go`, you can learn more about the
   details of this step in ["Validating JSON with JSON Typedef in
   Golang"](/docs/golang/validation).

3. Once the input is validated against the schema, you can confidently
   deserialize the input into the datatype generated by `jtd-codegen`. From here
   on out, you can write some beautiful, type-safe code.

Let's demonstrate all of this. In the same directory where you did steps 2 and
3, add a file called `demo.go`. In it, we'll add a function that sums up all of
the favorite numbers of a user, using the `User` struct that `jtd-codegen`
generated from us in step 3:

```go
package main

import (
	"example.com/codegen-demo/user"
)

func sumFavoriteNumbers(u user.User) float64 {
	sum := 0.0
	for _, n := range u.FavoriteNumbers {
		sum += n
	}

	return sum
}
```

Now comes the tricky part: when we read in some unstruted, unvalidated JSON, how
do we make sure that it's a correct user? If `favoriteNumbers` is something
other than an array of numbers, then if we try to `json.Unmarshal` into the
input into a `User`, we'll get an error. That's a good thing, but it's
oftentimes confusing to users when we give them errors from the `encoding/json`
package; they're usually too low-level and Go-specific for users to understand
what they did wrong.

Let's keep adding onto `demo.go`, and let's illustrate an example of a "good"
input and a "bad" input:

```go
// continued from above ...

const goodInput = `{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, 3.14, 42]
}`

// A subtle badness in this input: favoriteNumbers[1] is a string, not a
// number.
const badInput = `{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, "3.14", 42]
}`
```

Now we can put it all together: we can write a function which validates the
input using the `json-typedef-go` module, and only if that validation is
successful do we call `sumFavoriteNumbers`:

```go
// Update the imports at the top of the file:
import (
	"encoding/json"
	"fmt"

	"example.com/codegen-demo/user"
	"github.com/jsontypedef/json-typedef-go"
)
```

```go
// continued from above ...

func processInput(s string) float64 {
	// You can also construct `schema` by parsing it from JSON. To keep things as
	// simple as possible here, we'll skip that.
	schema := jtd.Schema{
		Properties: map[string]jtd.Schema{
			"id":        jtd.Schema{Type: jtd.TypeString},
			"firstName": jtd.Schema{Type: jtd.TypeString},
			"lastName":  jtd.Schema{Type: jtd.TypeString},
			"favoriteNumbers": jtd.Schema{
				Elements: &jtd.Schema{Type: jtd.TypeFloat64},
			},
		},
	}

	var parsedInput interface{}
	if err := json.Unmarshal([]byte(s), &parsedInput); err != nil {
		fmt.Println(err)
		return 0
	}

	if errs, _ := jtd.Validate(schema, parsedInput); len(errs) > 0 {
		fmt.Println(errs)
		return 0
	}

	var u user.User
	json.Unmarshal([]byte(s), &u)
	return sumFavoriteNumbers(u)
}

func main() {
	fmt.Println(processInput(goodInput))
	fmt.Println(processInput(badInput))
}
```

All of this is working code. Putting it all together, in a file called
`demo.go`, you get:

```bash
go run demo.go
```

```text
46.14
[{[favoriteNumbers 1] [properties favoriteNumbers elements type]}]
0
```

When the input is good, we can process it in a type-safe way. When the input is
bad, we get a specific, portable set of errors that we can return to the user.
