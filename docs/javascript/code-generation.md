---
title: "Generating TypeScript from JSON Typedef Schemas"
sidebar_label: "Code Generation"
---

JSON Type Definition is a schema language for JSON that's designed for code
generation. In this article, you'll learn:

* How to generate TypeScript code from a JSON Typedef schema,
* How to use that generated code in your applications

## Prerequisite: Install `jtd-codegen`

The `jtd-codegen` tool generates code from JSON Typedef schemas. It supports
many languages, TypeScript being one of them. To install `jtd-codegen`, you have
a few options:

### Install with Homebrew

This option is recommended if you're on macOS.

```bash
brew install jsontypedef/jsontypedef/jtd-codegen
```

### Install with Docker

This option is recommended on non-Mac platforms, or if you're running
`jtd-codegen` in some sort of script and you want to make sure that everyone
running the script uses the same version of `jtd-codegen`.

```bash
docker pull jsontypedef/jtd-tools
```

### Install with Cargo

This option is recommended if you already have `cargo` installed, or if you
would prefer to use a version of `jtd-codegen` compiled on your machine:

```bash
cargo install jtd-codegen
```

## Step 1: Write your schema

Before we can generate code from a JSON Typedef schema, we need a schema to work
with. There are a number of ways you can get ahold of a schema:

* You could write one yourself
* You could generate one from existing data, using a tool like
  [`jtd-infer`](/docs/tools/jtd-infer).

Let's assume, for the purposes of this article, that you want to make sure an
inputted JSON is a valid "user", where a user looks likething like this:

```json
{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, 3.14, 42]
}
```

A JSON Typedef schema that can describe this sort of data looks like this:

```json
{
  "properties": {
    "id": { "type": "string" },
    "firstName": { "type": "string" },
    "lastName": { "type": "string" },
    "favoriteNumbers": {
      "elements": { "type": "float64" }
    }
  }
}
```

To follow along with this example, put that schema in a file called
`user.jtd.json` -- there's nothing special about the `.jtd.json` extension, but
it is the conventional file extension to use for JSON Typedef schemas.

## Step 2: Create a directory for your generated code

The `jtd-codegen` tool will always output code into a directory. Create a
directory for `jtd-codegen` to output into.

For this demo, let's make a directory called `user`:

```bash
mkdir user
```

## Step 3: Call `jtd-codegen` with your schema

Next, all we need to do is invoke `jtd-codegen`, providing it with the schema
(in `user.jtd.json`) and the output directory (`user/`). Here's how you do that:

```bash
jtd-codegen --typescript-out=user -- user.jtd.json
```

Or, if you installed `jtd-codegen` with Docker, run:

```bash
docker exec -it jsontypedef/jtd-tools /jtd-codegen --typescript-out=user -- user.jtd.json
```

And that's all you have to do! Inside `user/index.ts`, you should see something
like this:

```ts
export interface User {
  favoriteNumbers: number[];
  firstName: string;
  id: string;
  lastName: string;
}
```

Try to play around with `user.jtd.json`, and then re-running `jtd-codegen`. Try
adding nested objects, and seeing how `jtd-codegen` behaves!

## Step 4: Integrating the generated code into your app

In the previous steps, we generated code from a JTD schema. But that's not very
useful on its own; what you *really* want to do is be able to use the generated
code in your application. In this section, we'll see how to do that.

`jtd-codegen`-generated code integrates in your app in a three-step process:

1. You accept some JSON input in whatever way makes sense for your application
   -- perhaps you read it from a file, from an HTTP request, or from STDIN.
   That's outside the scope of JSON Typedef's purview.

   To keep things super simple, we'll mostly omit this in this article. Instead,
   we'll just `JSON.parse` a hard-coded "input".

2. You validate the JSON input against a JSON Typedef schema. You can do this
   via the `jtd` NPM package.

   If you're unfamiliar with `jtd`, you can learn more about the details of this
   step in ["Validating JSON with JSON Typedef in
   JavaScript"](/docs/javascript/validation).

3. Once the input is validated against the schema, you can confidently cast the
   input into the datatype generated by `jtd-codegen`. From here on out, you can
   write some beautiful, type-safe code.

Let's demonstrate all of this. In the same directory where you did steps 2 and
3, add a file called `demo.ts`. In it, we'll add a function that sums up all of
the favorite numbers of a user, using the `User` interface that `jtd-codegen`
generated from us in step 3:

```ts
import { User } from "./user";

function sumFavoriteNumbers(user: User): number {
  let sum = 0;
  for (const favoriteNumber of user.favoriteNumbers) {
    sum += favoriteNumber;
  }

  return sum;
}
```

Now comes the tricky part: when we read in some unstruted, unvalidated JSON, how
do we make sure that it's a correct user? If `favoriteNumbers` is missing, or if
it is something other than an array of numbers, then `sumFavoriteNumbers` will
do nonsensical things.

Let's keep adding onto `demo.ts`, and let's illustrate an example of a "good"
input and a "bad" input:

```ts
// continued from above ...

const goodInput = `{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, 3.14, 42]
}`;

// A subtle badness in this input: favoriteNumbers[1] is a string, not a
// number.
const badInput = `{
  "id": "123",
  "firstName": "John",
  "lastName": "Doe",
  "favoriteNumbers": [1, "3.14", 42]
}`;
```

Now we can put it all together: we can write a function which validates the
input using the `jtd` package, and only if that validation is successful do we
call `sumFavoriteNumbers`:

```ts
// Add this to the top of the file:
import { Schema, validate } from "jtd";
```

```ts
// continued from above ...

function processInput(input: string): number {
  // This is the schema from step (2).
  const schema = {
    "properties": {
      "id": { "type": "string" },
      "firstName": { "type": "string" },
      "lastName": { "type": "string" },
      "favoriteNumbers": {
        "elements": { "type": "float64" }
      }
    }
  } as Schema;

  const parsedInput = JSON.parse(input);
  const validationErrors = validate(schema, parsedInput);
  if (validationErrors.length === 0) {
    // This type-cast is safe, because User is generated by jtd-codegen from
    // the same schema we just successfully validated against.
    const user = parsedInput as User;
    return sumFavoriteNumbers(user);
  } else {
    console.error("invalid input", validationErrors);
    return 0;
  }
}
```

All of this is working code. Putting it all together, in a file called
`demo.ts`, you get:

```bash
# You may need to first run "npm install -g typescript ts-node" if ts-node
# doesn't already exist for you.
ts-node demo.ts
```

```text
46.14
invalid input [
  {
    instancePath: [ 'favoriteNumbers', '1' ],
    schemaPath: [ 'properties', 'favoriteNumbers', 'elements', 'type' ]
  }
]
0
```

When the input is good, we can process it in a type-safe way. When the input is
bad, we get a specific, portable set of errors that we can return to the user.
